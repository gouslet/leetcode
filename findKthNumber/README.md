# 668. 乘法表中第k小的数
几乎每一个人都用 乘法表。但是你能在乘法表中快速找到第k小的数字吗？

给定高度m 、宽度n 的一张 m * n的乘法表，以及正整数k，你需要返回表中第k 小的数字。

# 示例
## 例 1：

### 输入: 
m = 3, n = 3, k = 5
### 输出: 
3
### 解释: 
乘法表:  
1	2	3
2	4	6
3	6	9

第5小的数字是 3 (1, 2, 2, 3, 3).

## 例 2：

### 输入: 
m = 2, n = 3, k = 6
### 输出: 
6
### 解释: 
乘法表:  
1	2	3  
2	4	6  

第6小的数字是 6 (1, 2, 2, 3, 4, 6).

## 注意：
- m 和 n 的范围在 [1, 30000] 之间。
- k 的范围在 [1, m * n] 之间。

# 解答
## 解答一
### 分析
令f[x]为乘法表中值为x+1的元素个数，g[x]为乘法表中小于等于x+1的元素个数之和，则第k小的数为满足g[x] <= k < g[x+1]的x

计算f[x]的过程
- f[x]初始值为0，令i从1增加到m，j从1增加到n，当i*j=x时，f[x]加一

计算g[x]的过程
- 将小于等于x的f[x]值相加求和

复杂度
时间复杂度：O(k)
空间复杂度：O(k)

## 解答二
### 分析
设m <= n，以[m,1]和[1,m]所在直线l1和[1,n]y与[m,n-m+1]所在直线l2将乘法表分为三部分，max1为直线l1上元素最大值，则左上角（包含直线l1上的元素）部分A均不大于max1，元素个数为count1 = m(m+1)/2，min2为直线l2上元素最小值，则右下角B（包含直线l2上的元素）元素均不小于min2，元素个数为count2 = m(m+1)/2，剩余元素位于两条直线之间，且均不小于A的元素，均不大于B的元素，元素个数为count3 = m*n-count1-count2

- 如果k < count1，则应该在A中寻找第k小的元素
- 如果k == count1，则第k小的元素应该为直线l1上的最大元素
- 如果count1 < k <= count1+count3 ，则应该在C中寻找k-count1小的元素
- 如果k > ccount1+count3 ，则应该在B中寻找第k-count1-count3小的元素

令函数f(l int,alo,ahi,blo,bhi int, k int)为在以[1,blo],[1,bhi][alo,1][ahi,1]为顶点的梯形中寻找第k大的数

函数g(l int,alo,ahi,blo,bhi int, k int)为在以[m,blo],[m,bhi][alo,m][ahi,m]为顶点的梯形中寻找第k大的数

## 解答三
### 分析
使用二分法，查找乘法表中小于等于x的数的个数w

对于第i行，乘法表中的元素均为i的倍数，所以每一行小于等于x的数的个数为$min\{\lfloor x/i\rfloor,n\}$
所以乘法表中小于等于x的数的个数为
$$
g(x) = \sum_{i=1}^{m} min\{\lfloor x/i\rfloor,n\}
$$

- 当g(x) >= k时，
  - 如果g(x-1) < k，说明第k小的数为x，
  - 否则，说明第k小的数位于[1,x)中，
- 当g(x) < k时，说明第k小的数位于(x，m*n]中，

时间复杂度：O(mlog(mn))
空间复杂度：O(1)

## 解答三
### 分析
用sort.Search方法返回满足g(n)>=k的最小的n
时间复杂度：O(mlog(mn))
空间复杂度：O(1)